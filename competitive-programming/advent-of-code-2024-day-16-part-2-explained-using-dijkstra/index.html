<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Detailled explaination of how I solved the part 2 of day 16 for AoC 2024 using Dijkstra algorithm, with a link to my Rust implementation.">
    <title> | Advent of Code 2024 Day 16 Part 2 Explained - Using Dijkstra</title>
    
    <link rel="stylesheet" href="https://antoineprdhmm.github.io/style.css?h=0b13e1dc1cf44b248c9d">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
    
    
        
    
</head>
<body>
    
<header>
    <div class="header-content">
        <h1><a href="https:&#x2F;&#x2F;antoineprdhmm.github.io"></a></h1>
        <nav class="header-links">
            <a href="https:&#x2F;&#x2F;antoineprdhmm.github.io" class="home-link">&larr; Home</a>
        </nav>
    </div>
</header>

    
    
<main>
    <article class="post">
        <header class="post-header">
            <h1 class="post-title">Advent of Code 2024 Day 16 Part 2 Explained - Using Dijkstra</h1>
            
            
            <div class="post-meta">
                
                <time datetime="2025-04-04" class="post-date">
                    April 04, 2025
                </time>
                

                
                
                

                
            </div>
            
        </header>
        
        <div class="post-content">
            <p>Advent of Code 2024 has been a smooth ride for me until Day 16. The second part was more challenging but fun to solve.</p>
<p>I noticed a lot of people on Reddit were struggling with it, so I decided to share my approach using Dijkstra's algorithm.</p>
<p>Hopefully, this will help some of you.</p>
<p>I haven‚Äôt included code snippets here, but you can find my <a href="https://github.com/antoineprdhmm/advent_of_code/blob/master/src/y2024/day16/mod.rs">Rust implementation on GitHub</a>.</p>
<h2 id="part-1-dijkstra">Part 1: Dijkstra</h2>
<p>I won‚Äôt dive too deep into Part 1 since it‚Äôs relatively straightforward. I managed to solve it using <a href="https://en.wikipedia.org/wiki/Dijkstra&#x27;s_algorithm">Dijkstra's algorithm</a>.</p>
<p>The only twist was managing the <strong>direction</strong> and <strong>rotation</strong>.</p>
<p>Dijkstra‚Äôs output is a HashMap, where</p>
<ul>
<li>The key is a tile and a direction.</li>
<li>The value is the smallest score for that entry.</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">type </span><span>SmallestScoresByTile = HashMap&lt;(Position, Direction), </span><span style="color:#b48ead;">usize</span><span>&gt;;
</span></code></pre>
<p>Since each tile in the maze can be reached from <strong>four different directions</strong>, we need to consider all of them.</p>
<p><code>TileCandidateScore</code> struct represents a candidate score for a tile‚Äôs direction.</p>
<p>These candidates are pushed into a <strong>min BinaryHeap</strong>. Since the heap sorts candidates by their scores (smallest first), the lowest score pops first.</p>
<p>Once a tile and direction combination pops, future candidates for that combination are ignored, because the smallest score has already been found.</p>
<p>The exploration starts with tile <code>S</code> with a score of <code>0</code>, since it's the starting point. From there, the algorithm explores the maze.</p>
<p>For Part 1, you can stop once you reach <code>E</code>. However, Part 2 requires collecting the best scores for <strong>all tiles in the maze</strong>.</p>
<p>The answer to Part 1 is simply the <strong>smallest value</strong> among the four entries for tile <code>E</code> in <code>SmallestScoresByTile</code>.</p>
<h2 id="part-2-finding-all-best-paths">Part 2: Finding All Best Paths</h2>
<p>In Part 1, we only needed to find <em>one</em> best path to reach <code>E</code>. But there could be multiple paths with the same best score.</p>
<p>The goal of Part 2 is to determine the number of <strong>distinct tiles</strong> that belong to a best path. To do this, we need a way to trace <em>all</em> best paths.</p>
<p>Fortunately, Dijkstra‚Äôs algorithm already gives us all the best paths. So, we can reuse the code from Part 1.</p>
<h3 id="recycling-part-1-s-output">Recycling Part 1‚Äôs Output</h3>
<p>The output of our Dijkstra function from Part 1 is this <code>HashMap</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">type </span><span>SmallestScoresByTile = HashMap&lt;(Position, Direction), </span><span style="color:#b48ead;">usize</span><span>&gt;;
</span></code></pre>
<p>Each tile of the maze can be reached in <strong>4 different states</strong>‚Äîone per direction. The value in the <code>HashMap</code> represents the <strong>smallest score</strong> for reaching that tile from a given direction.</p>
<p>The question is: how to use this HashMap to find all best paths?</p>
<h3 id="let-s-take-a-simple-example">Let‚Äôs Take a Simple Example</h3>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>#####
</span><span>###E#
</span><span>#...#
</span><span>#.#.#
</span><span>#...#
</span><span>#.###
</span><span>#S..#
</span><span>#####
</span></code></pre>
<ul>
<li><code>E</code> is located at <code>(1, 3)</code></li>
<li><code>S</code> is located at <code>(6, 1)</code></li>
</ul>
<p>There are 2 best paths to reach <code>E</code> from <code>S</code>.</p>
<p>The best score at <code>E</code> is <code>3007</code> with direction <code>NORTH</code>.</p>
<p>For each best paths, there are</p>
<ul>
<li>8 tiles</li>
<li>3 rotations</li>
</ul>
<p><code>(8-1) * 1 + 3 * 1000 = 3007</code></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>#####
</span><span>###O#
</span><span>#OOO#
</span><span>#O#O#
</span><span>#OOO#
</span><span>#O###
</span><span>#O..#
</span><span>#####
</span></code></pre>
<p>The best score at tile <code>E</code> is obtained with direction <code>NORTH</code>. Other directions at <code>E</code> have higher scores, because they just involve unnecessary rotations from <code>3007 NORTH</code>.</p>
<h3 id="tracing-backwards-from-e">Tracing Backwards from <code>E</code></h3>
<p>So the best paths comes from the adjacent tile in <strong>opposite direction</strong>.</p>
<p><code>SOUTH</code> to <code>(1, 3)</code> is <code>(2, 3)</code>.</p>
<p>Since the best score at <code>E</code> is achieved facing <code>NORTH</code>, the optimal path must come from an adjacent tile in the <strong>opposite direction</strong>‚Äî<code>SOUTH</code>.</p>
<p>So, the predecessor tile is <code>(2, 3)</code>.</p>
<p>Let‚Äôs look at the entries in the <code>HashMap</code> for <code>(2, 3)</code> .</p>
<ul>
<li><code>3006 NORTH</code> (from <code>(3, 3)</code> with direction <code>NORTH</code>)</li>
<li><code>2006 EAST</code> (from <code>(2, 2)</code> with direction <code>EAST</code>)</li>
<li><code>3006 SOUTH</code> (from <code>(2, 2)</code> with direction <code>EAST</code> + clockwise rotation)</li>
<li><code>4006 WEST</code> (but 4006 &gt; 3007, so we can ignore it)</li>
</ul>
<p>Now, <strong>let‚Äôs see which entries for <code>(2, 3)</code> can contribute to a best path ending at <code>E</code></strong> (<code>3007 NORTH</code>).</p>
<table><thead><tr><th style="text-align: left">Entry</th><th style="text-align: left">Analysis</th><th style="text-align: center">Valid</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>3006 NORTH</code></td><td style="text-align: left">Already facing <code>NORTH</code>, just move forward.<br><strong>3006 + 1 = 3007</strong></td><td style="text-align: center">‚úÖ</td></tr>
<tr><td style="text-align: left"><code>2006 EAST</code></td><td style="text-align: left">Facing <code>EAST</code>. Need to face <code>NORTH</code>, then move forward.<br><strong>2006 + 1000 + 1 = 3007</strong></td><td style="text-align: center">‚úÖ</td></tr>
<tr><td style="text-align: left"><code>3006 SOUTH</code></td><td style="text-align: left">Facing <code>SOUTH</code>. Need to face <code>NORTH</code>, then move forward.<br><strong>2006 + 2000 + 1 = 4007</strong></td><td style="text-align: center">‚ùå</td></tr>
<tr><td style="text-align: left"><code>4006 WEST</code></td><td style="text-align: left">Already higher than <code>3007</code></td><td style="text-align: center">‚ùå</td></tr>
</tbody></table>
<p>Both 3006 NORTH and 2006 EAST are valid entries to reach (1, 3) with a score of 3007. <strong>Because there are two valid entries, it means two best paths pass through this tile.</strong></p>
<h3 id="recursively-finding-all-best-paths">Recursively Finding All Best Paths</h3>
<p>The same logic applies recursively. Now, we need to do the same thing we did for <code>E 3007 NORTH</code>, but for <code>(2, 3) 3006 NORTH</code> and <code>(2, 3) 2006 EAST</code>.</p>
<p>Once that‚Äôs done, we‚Äôve found all the tiles belonging to the best paths.</p>
<p>And that‚Äôs it! üéâ</p>

        </div>
    </article>
</main>

    
    <footer>
        <div class="footer-content">
            <p>&copy; 2025 . All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
